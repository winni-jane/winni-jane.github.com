插入类排序、交换类（快速排序（冒泡）属于交换类）排序、选择类排序、归并类排序、基数类排序。

排序方法的稳定性:若Ki=Kj，排序后Ri与Rj两者间是否保持原次序不变。
内部排序与外部排序:根据排序开始时所有待排记录的存放位置或者说根据排序过程中是否需要访问外存分。

排序的数据类型与存储结构定义:

```
#define MAXSIZE  20     //待排顺序表最大长度
typedef  int  KeyType;    // 关键字类型为整数类型
typedef  struct {
   KeyType   key;             // 关键字项
   InfoType  otherinfo;  // 其它数据项
} RcdType;                     // 记录类型
typedef  struct {
   RcdType    r[MAXSIZE+1]; //r[0]闲置留作它用
    int               length;                  //记录个数
} SqList; //顺序表存储,因记录元素个数固定

```

10.2 插入排序 （直接插入排序、折半插入排序、表插入排序、希尔排序）

思路:首记录自身有序,从第二个记录到最末一个,每次都将当前记录插入其前有序表中使得仍然有序。

实现:将待插入记录L.r[i]与其前有序段L.r[1..i-1]中记录从后向前比较：若L.r[i]>=L.r[i-1]则L.r[i]不需移动;否则设置哨L.r[0]=L.r[i]，先后移L.r[i-1]，对其前的元素L.r[j]只要大于哨中记录就后移。最后将哨中记录填入即可。


```
void InsertSort(SqList &L){
  for(i=2;i<=L.length; ++i){
    if( LT(L.r[i],L.r[i-1]) ) { //比较
      L.r[0]=L.r[i];//哨兵  //哨初始化,也算作移动
      L.r[i]=L.r[i-1];//移动
      for(j=i-2;LT(L.r[0],L.r[j]);--j)  //比较
           {   L.r[j+1]=L.r[j];//后移  }  //移动
      L.r[j+1]=L.r[0];//填入,也算作移动
    }
  }

```
直接插入排序的性能分析:

最好情况:待排序列按关键字非递减有序（正序）

最坏情况:待排序列按关键字非递增有序（逆序）

![](picture/10/1.png '')

时间复杂度O(n^2),平均操作次数(n^2)/4空间复杂度O(1),稳定！


2、折半插入排序

思路:因R[1..i-1]是一个按关键字有序的序列（不是说原先序列是有序的，这里是排的序），可用折半查找实现“在R[1..i-1]中的定位第一个比待插入记录大的元素”，如此实现的插入排序为折半插入排序。

![](picture/10/2.png '')

low=1,high=i-1;与中间元素比,若中间元素大则high=m-1,使得high右侧均比待插入元素大,且定位区间缩小一半;否则,low=m+1,使得low左侧均比待插入元素小或相等,区间小一半,至low<=high不成立(low=high+1)。此时,high右侧是第一个比待插入元素严格大的元素，插入位置为high+1 (实际等于low）。稳定

![](picture/10/3.png '')


```
void BInsertSort(SqList &L){
  for(i=2;i<=L.length;++i){
     L.r[0]=L.r[i];//记录待插入元素以备填入时用    
     low = 1;   high = i-1;
     while (low<=high) { 
        m=(low+high)/2;  //下取整
        if(LT(L.r[0].key,L.r[m].key))high=m-1;  
       else low=m+1;
     }
     for(j=i-1;j>=high+1;--j)L.r[j+1]=L.r[j];//后移
     L.r[high+1]=L.r[0];//填入
  }}//T(n)=n2;稳定，但基本有序时不如直接插入排序


```

4、希尔排序(设增量序列,子序列直接用插入排序)

方法:每一趟希尔排序将记录序列分成d个子序列，分别对各子序列进行直接插入排序。最后一趟d=1时对全部记录进行直接插入排序。又称缩小增量排序

![](picture/10/4.png '')

希尔排序算法：
一趟希尔排序,增量为dk，相比普通插入排序唯增量由1变dk


```
void ShellInsert ( SqList &L, int dk ) {
//
 for ( i=dk+1; i<=L.length; ++i )//前dk个各自为一个有序块
     if ( L.r[i].key< L.r[i-dk].key){
         L.r[0] = L.r[i];            // 哨
         for (j=i-dk;  j>0&&(L.r[0].key<L.r[j].key); j-=dk)
                L.r[j+dk] = L.r[j];  //记录后移一增量
         L.r[j+dk] = L.r[0];        
      }
} 


void ShellSort(SqList &L, int dlta[],int t){
    //按增量序列dlta[0..t-1]进行希尔排序,d[t-1]必须为1
    for (k=0; k<t; ++t)  ShellInsert(L, dlta[k]);
}

```

希尔排序性能说明：

基本思想：子序列排好序后大序列基本有序，此时直接插入排序效率高, 如最后一次直接插入排序肯定比最初就对全部元素进行直接插入排序好。此外，子序列由于元素个数小，故多余的操作会比较少。
时间是d序列的函数,而d的确定尚待研究,实验O(n1.3)；不稳定

9.3 快速排序(交换类排序)

一、起泡排序
二、一趟快速排序
三、快速排序


一、冒泡排序算法Bubble Sort

思路：每一趟排序时，从首记录开始相邻两数进行比较，逆序则交换(将小的换到前头(最后序列是递增的))，如此，则每趟排序都会使当前“最大”的数“沉到末尾”，小的数逐步“上升”,无序块变小。如此至多N-1趟后排序完成,若中间某趟不进行交换则排序也完成。 

![](picture/10/5.png '')


```

void bubble_sort(int a[], int n)
{
    int i, j, temp;
    for (j = 0; j < n - 1; j++)
        for (i = 0; i < n - 1 - j; i++)
        {
            if(a[i] > a[i + 1])
            {
                temp = a[i];
                a[i] = a[i + 1];
                a[i + 1] = temp;
            }
        }
}


```

ppt上的算法


![](picture/10/6.png '')

/*i表趟数,j表较元素中的前者(从1开始),hasExchange标记有无交换*/
正序一趟即可,比较n-1次,交换0次;

逆序n-1趟,第i趟比较n-i次,交换n-i次,总比较或交换次数均n(n-1)/2,T(n)=O(n^2),S(n)=O(1),稳定

二、一趟快速排序Quick Sort



