插入类排序、交换类（快速排序（冒泡）属于交换类）排序、选择类排序、归并类排序、基数类排序。

排序方法的稳定性:若Ki=Kj，排序后Ri与Rj两者间是否保持原次序不变。
内部排序与外部排序:根据排序开始时所有待排记录的存放位置或者说根据排序过程中是否需要访问外存分。

排序的数据类型与存储结构定义:

```
#define MAXSIZE  20     //待排顺序表最大长度
typedef  int  KeyType;    // 关键字类型为整数类型
typedef  struct {
   KeyType   key;             // 关键字项
   InfoType  otherinfo;  // 其它数据项
} RcdType;                     // 记录类型
typedef  struct {
   RcdType    r[MAXSIZE+1]; //r[0]闲置留作它用
    int               length;                  //记录个数
} SqList; //顺序表存储,因记录元素个数固定

```

10.2 插入排序 （直接插入排序、折半插入排序、表插入排序、希尔排序）

思路:首记录自身有序,从第二个记录到最末一个,每次都将当前记录插入其前有序表中使得仍然有序。

实现:将待插入记录L.r[i]与其前有序段L.r[1..i-1]中记录从后向前比较：若L.r[i]>=L.r[i-1]则L.r[i]不需移动;否则设置哨L.r[0]=L.r[i]，先后移L.r[i-1]，对其前的元素L.r[j]只要大于哨中记录就后移。最后将哨中记录填入即可。


```
void InsertSort(SqList &L){
  for(i=2;i<=L.length; ++i){
    if( LT(L.r[i],L.r[i-1]) ) { //比较
      L.r[0]=L.r[i];//哨兵  //哨初始化,也算作移动
      L.r[i]=L.r[i-1];//移动
      for(j=i-2;LT(L.r[0],L.r[j]);--j)  //比较
           {   L.r[j+1]=L.r[j];//后移  }  //移动
      L.r[j+1]=L.r[0];//填入,也算作移动
    }
  }

```
直接插入排序的性能分析:

最好情况:待排序列按关键字非递减有序（正序）

最坏情况:待排序列按关键字非递增有序（逆序）

![](picture/10/1.png '')

时间复杂度O(n^2),平均操作次数(n^2)/4空间复杂度O(1),稳定！


2、折半插入排序

思路:因R[1..i-1]是一个按关键字有序的序列（不是说原先序列是有序的，这里是排的序），可用折半查找实现“在R[1..i-1]中的定位第一个比待插入记录大的元素”，如此实现的插入排序为折半插入排序。

![](picture/10/2.png '')

low=1,high=i-1;与中间元素比,若中间元素大则high=m-1,使得high右侧均比待插入元素大,且定位区间缩小一半;否则,low=m+1,使得low左侧均比待插入元素小或相等,区间小一半,至low<=high不成立(low=high+1)。此时,high右侧是第一个比待插入元素严格大的元素，插入位置为high+1 (实际等于low）。稳定

![](picture/10/3.png '')


```
void BInsertSort(SqList &L){
  for(i=2;i<=L.length;++i){
     L.r[0]=L.r[i];//记录待插入元素以备填入时用    
     low = 1;   high = i-1;
     while (low<=high) { 
        m=(low+high)/2;  //下取整
        if(LT(L.r[0].key,L.r[m].key))high=m-1;  
       else low=m+1;
     }
     for(j=i-1;j>=high+1;--j)L.r[j+1]=L.r[j];//后移
     L.r[high+1]=L.r[0];//填入
  }}//T(n)=n^2;稳定，但基本有序时不如直接插入排序


```

4、希尔排序(设增量序列,子序列直接用插入排序)

方法:每一趟希尔排序将记录序列分成d个子序列，分别对各子序列进行直接插入排序。最后一趟d=1时对全部记录进行直接插入排序。又称缩小增量排序

![](picture/10/4.png '')

希尔排序算法：
一趟希尔排序,增量为dk，相比普通插入排序唯增量由1变dk


```
void ShellInsert ( SqList &L, int dk ) {
//
 for ( i=dk+1; i<=L.length; ++i )//前dk个各自为一个有序块
     if ( L.r[i].key< L.r[i-dk].key){
         L.r[0] = L.r[i];            // 哨
         for (j=i-dk;  j>0&&(L.r[0].key<L.r[j].key); j-=dk)
                L.r[j+dk] = L.r[j];  //记录后移一增量
         L.r[j+dk] = L.r[0];        
      }
} 


void ShellSort(SqList &L, int dlta[],int t){
    //按增量序列dlta[0..t-1]进行希尔排序,d[t-1]必须为1
    for (k=0; k<t; ++t)  ShellInsert(L, dlta[k]);
}

```

希尔排序性能说明：

基本思想：子序列排好序后大序列基本有序，此时直接插入排序效率高, 如最后一次直接插入排序肯定比最初就对全部元素进行直接插入排序好。此外，子序列由于元素个数小，故多余的操作会比较少。
时间是d序列的函数,而d的确定尚待研究,实验O(n1.3)；不稳定

9.3 快速排序(交换类排序)

一、起泡排序
二、一趟快速排序
三、快速排序


一、冒泡排序算法Bubble Sort

思路：每一趟排序时，从首记录开始相邻两数进行比较，逆序则交换(将小的换到前头(最后序列是递增的))，如此，则每趟排序都会使当前“最大”的数“沉到末尾”，小的数逐步“上升”,无序块变小。如此至多N-1趟后排序完成,若中间某趟不进行交换则排序也完成。 

![](picture/10/5.png '')


```

void bubble_sort(int a[], int n)
{
    int i, j, temp;
    for (j = 0; j < n - 1; j++)
        for (i = 0; i < n - 1 - j; i++)
        {
            if(a[i] > a[i + 1])
            {
                temp = a[i];
                a[i] = a[i + 1];
                a[i + 1] = temp;
            }
        }
}


```

ppt上的算法


![](picture/10/6.png '')

/*i表趟数,j表较元素中的前者(从1开始),hasExchange标记有无交换*/
正序一趟即可,比较n-1次,交换0次;

逆序n-1趟,第i趟比较n-i次,交换n-i次,总比较或交换次数均n(n-1)/2,T(n)=O(n^2),S(n)=O(1),稳定

二、一趟快速排序Quick Sort

快速排序思路:将待排记录一次划分成两块,前块记录均小于后块, 再分别对两小块递归划分. 到最后块长1便有序
一趟快速排序:用L.r[low]作“枢轴”,保存该记录到L.r[0],之后low和high分别从两侧交替向中间移动:{high向左找第一个关键字小于枢轴的记录,移动到左侧low位置;再令low向右找第一个关键字大于枢轴的记录,移动到右侧high位置.如此low走过处元素均比哨小,high走过处均比哨大 },重复至low=high,左侧均小于枢轴,右侧均大于枢轴,将枢轴记录填入,完成分块


```
int Partition(SqList &L, int low, int high){
//快速排序中一次划分的算法(10.6b),返回划分位置
 L.r[0]=L.r[low];pivotkey=L.r[low].key;  //保存枢轴
 while (low<high) {//从两端交替想中间扫描
    while (high>low && L.r[high].key>=pivotkey )             		--high;//从右侧找第一个小于枢轴的记录
    L.r[low] = L.r[high] ; //将比枢轴小的记录移动到低端
    while ( low<high && L.r[low].key<=pivotkey ) 
       		++low; //从左侧找第一个大于枢轴的记录
    L.r[high] = L.r[low] ; //将比枢轴大的记录移动到高端
 }
  L.r[low]=L.r[0];//枢轴记录到位
  return low;          // 返回枢轴最后所在位置
}

```

![](picture/10/7.png '')


三、快速排序

   首先对无序的大序列进行“一次划分”，之后分别对分割所得两个小子序列“递归”进行快速排序。待快长为1时自然有序


```
void QSort (SqList &L,  int low,  int high ) {
  // 对顺序表L的子序列L.r[low..high]作快速排序
  if (low<high) {             // 块长大于1
       //对L.r[low..high]进行划分,pivotloc是枢轴最终位置
         pivotloc = Partition(L,low, high); 
         QSort(L, low, pivotloc-1); //对小块递归排序
         QSort(L, pivotloc+1, t); //对大块递归排序

  }   }


void QuickSort(SqList &L){QSort(L,1,L.length);}

```

结论: （以2为底）快速排序的平均时间复杂度为O(nlogn);（任何一种按常数比例进行划分所产生的递归树的深度都为θ（nlogn），其中每一层的代价为O(n），因而不管常数比例是什么，总的运行时间都为θ（nlogn），）平均性能在各排序算法中最优;

最坏情况运行时间为θ（n^2），且最坏情况发生在每次划分过程产生的两个区间分别包含n-1个元素和1个元素的时候。

 但递归过程中需要一个栈, 原本有序时枢轴均位于一端栈最长为n,空间复杂度最坏O(n), 此时退化为冒泡排序,最坏时间复杂度O(n^2)。平均情况下空间复杂度O(logn)，不稳定。

优化：1.三平均分区法（选用待排数组最左边、最右边和最中间的三个元素的中间值作为中轴）、2.根据分区大小调整算法（当数据集较小时，不必继续递归调用快速排序算法，而改为调用其他的对于小规模数据集处理能力较强的排序算法来完成。I）（插入排序对于这种“几乎”完成的排序数列有着接近线性的复杂度。这一改进被证明比持续使用快速排序算法要有效的多。）、3.不同的分区方案考虑（对于这种情况的一种改进办法就是将分区分为三块而不是原来的两块：一块是小于中轴值的所有元素，一块是等于中轴值的所有元素，另一块是大于中轴值的所有元素。）、4.并行的快速排序（会在实现代码中设定一个阀值，如果分区的元素数目多于该阀值的话，就创建一个新的线程来处理这个分区的排序，否则的话就进行递归调用来排序。）。

变种：随机化快排（随机选取一个元素作为主元）
 
     平衡快排（尽可能地选择一个能够代表中值的元素作为关键数据，选择这个数据的方法是取开头、结尾、中间3个数据，通过比较选出其中的中值。）

     外部快排（然后递归地对外部更小的部分，循环地对其他部分进行排序--> 缓冲区）
     三路基数快排（结合了基数排序（radix sort，如一般的字符串比较排序就是基数排序）和快排的特点，是字符串排序中比较高效的算法。）


![](picture/10/8.png '')


10.4 选择类排序

简单选择排序
树形选择排序
堆排序


1、选择排序SelectSort

思路:每趟都选择当前最小的元素交换到“无序块”的最前，共N-1趟则完成排序


```
for(i = 1;i <= n-1;++i)
{
   min = i;
   for(j = i+1;j <=n;j++)
     {
         if(a[min]>a[j])
           { min = j; }
     }

   if(min != i)
    {
      a[min]<=>a[i];
    }
}

i:趟数或无序块首位置
min:当前最小记录下标

```

比较始终n-1+…+1=n(n-1)/2次;
移动至多 (n-1)次,最少0. T(n)=O(n^2)


2、堆排序HeapSort---堆的定义








