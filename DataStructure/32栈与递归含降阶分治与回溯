1、递归

无论是普通函数调用还是递归调用，系统都会在内存中自动创建一个栈保存场景切换的相关信息

如求阶乘：F(1)=1;   F(n)=n*F(n-1)

```

int f ( int  n )
{      
    int r;
    if(n= =1)r=1;  //f(n)=1错
    else    r=n*f (n-1);
    return r;
}

```
1.显式递归问题，如求Fibnacci数列
    F(n)=F(n-1)+F(n-2)递归公式；F(1)=1,F(2)=1边界条件

根据边界条件和递归关系是否明显可将问题分为显示递归和隐式递归两类，前者可直接写出递归函数，后者要通过认真分析找到边界条件，并通过降阶+分治+回溯找递归关系


Fibnacci数列：1、1、2、3、5、8、13、21、34、……  定义 F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=2，n∈N*）

   前一项与后一项的比值越来越逼近黄金分割0.618

将杨辉三角左对齐，成如图所示排列，将同一斜行的数加起来，即得一数列1、1、2、3、5、8、……

卢卡斯数列1、3、4、7、11、18…，
佩尔数列：1，2，5，12，29，…，    有|2*2-1*5|=|5*5-2*12|=…=1（该类数列的这种特征值称为勾股特征）。

f(n) = f(n-1) * p + f(n-2) * q，称为广义斐波那契数列。

对于Fibnacci数列中F(n)=F(n-1)+F(n-2)形式的递归公式，分析求f(5)的过程可知f(1)被多次重复调用，因此原因，求F(40)在Core2 T5500CPU上约费20秒时间，故此类问题要避免递归。

非递归改写：

```

public static int getFibonacciNum(int n){
        int first = 0;
        int second = 1;
        int fn = 0;
        for (int i = 2; i < n + 1; i++) {
            fn = first + second;
            first = second;
            second = fn;
        }
        return fn;
    }

方法二：
public static int getFibonacci(int n){
        int[] array = new int[n + 1];
        array[0] = 0;
        array[1] = 1;
        for (int i = 2; i < array.length; i++) {
            array[i] = array[i - 1] + array[i - 2];
        }
        return array[n];
    }

```

2.隐式递归—降阶

汉诺塔（hanoi）问题：总共有三根柱子，分别为A，B，C。初始状态下，Ａ柱中有N个盘子，这N个盘子有大有小，大的在下面，小的在上面。最终目标就是将Ａ柱上的所有盘子移到Ｃ柱上，中间可以经过B柱，过程中必须保持大盘在下面，小盘在上面。每次只移一个盘，大盘不能压小盘，要求输出搬运方案


![](picture/32/1.png '')


3. 隐式递归—分治         --树的相关操作

```

二叉树：

int TreeDepth(BiTree T){//求二叉树深
	if(T为空树)d=0;
	else{
	    d1=TreeDepth(T的左子树);
      d2=TreeDepth(T的右子树);
      if(d1>d2)
			d=d1+1;
		else
			d=d2+1;
	}
	return d;
}


```

4. 隐式递归—回溯(单解) --8皇后问题

在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 



利用栈将递归化为非递归，利用入栈、出栈。
















