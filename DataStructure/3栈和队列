3.1 栈
是定义在线性结构上的抽象数据类型。后进先出。
```
ADT   Stack {
       数据对象：D={ai|ai∈ElemSet,i=1,2,…,n,n>=0}
       数据关系：R={<ai-1,ai>|ai-1,ai∈D}，约定an为栈顶元素
       基本操作：
           InitStack (&S)
              操作结果:构造一个空栈
           DestroyStack(&S)
               初始条件: 栈S已存在
	 操作结果：销毁栈S
           ClearStack(&S)
 	 初始条件: 栈S已存在
	 操作结果:将S清为空栈
          Push(&S,e)
 	 初始条件: 栈S已存在
	 操作结果：插入e到栈顶
         Pop(&S,&e)
 	         初始条件: 栈S已存在且非空
	         操作结果：删除栈顶元素用e返回其值
          StackEmpty(S)
                 初始条件:栈S已经存在
                 操作结果:空栈返回TRUE,否则返回FALSE
         StackLength(S)
                 初始条件:栈S已经存在
                  操作结果:返回S中元素的个数
         GetTop(S,&e)
                  初始条件:栈S存在且非空
                  操作结果:用e带回S栈顶元素的值,栈顶不变
         StackTraverse(S,visit())
                  初始条件:栈S存在且非空
                  操作结果:从栈底到栈顶对S中各元素执行visit操作，一般用于输出栈元素

}  ADT  RationalNumber

```
顺序栈
```

 #define STACK_INIT_SIZE  100
 #define STACKINCREMENT   10
 typedef  ????  SElemType;
 typedef struct{
     SElemType *base;  //栈底指针
     SElemType *top;   //栈顶指针
     int   stacksize;  //栈容量
 }SqStack

```
顺序栈基本操作的实现

![](picture/3/1.png '')

```
Status InitStack(SqStack &S){
//构造空栈S  S.base=(SElemType*)malloc(STACK_INIT_SIZE*sizeof(SElemType))
 if(!S.base)exit(OVERFLOW);    //存储分配失败
  S.top=S.base;   //空栈
  S.stacksize=STACK_INIT_SIZE;
  return(OK);
}//InitStack

Status DestroyStack(SqStack &S){
    //销毁栈S
    free(S.base);
    S.base=NULL;
    S.top=NULL;
    S.stacksize=0;
    return OK;
}

Status ClearStack(SqStack &S){
    //置S为空栈
    S.top=S.base;  return OK;
}

Status Push(SqStack &S, SElemType e){
//插入e为栈顶元素
   if(S.top-S.base==S.stacksize){//栈满则应重新分配空间
     S.base=(SElemType *)
	        realloc(S.base,(S.stacksize+STACKINCREMENT)*sizeof(SElemType));
     if(!S.base)exit(OVERFLOW);
     S.top=(S.base+S.stacksize);//使得S.top重新指向栈顶,因realloc
     S.stacksize+=STACKINCREMENT;
   }
   *S.top++=e;    //top指向待插入位置    
   return(OK);
}//Push


Status Pop(SqStack &S,SElemType &e){
    //若栈不空则栈顶元素出栈并用e带回其值
    if(S.top==S.base)return ERROR;
    e=*(--S.top);     //栈顶元素为*(S.top-1)
     return OK;
}

Status StackEmpty(SqStack S)
{
      if(S.top==S.base)
            return TRUE;
      else 
             return FALSE;
}

int StackLength (SqStack S){ 
         return (S.top-S.base); 
}

Status GetTop(SqStack S,  SElemType &e){
        if(S.top==S.base)
             return ERROR;
        e=*(S.top-1);  //注意top指向待插入位置
        return OK;
}

Status StackTraverse(SqStack S,Status (*visit)(ElemType)){
	//从栈底元素到栈顶元素依次执行visit函数,常用于输出栈中元素
	ElemType *p=S.base;	
	if(S.base==S.top)printf("空栈\n");
	else	while(p<S.top){(*visit)(*p);++p;}
	return OK;
}//除遍历操作外时间复杂度均O(1)


```

4.链栈

若栈中元素的数目变化范围较大或不清楚栈元素的数目，就应该考虑使用链式存储结构。用链式存储结构表示的栈称作“链栈”。

链栈常用一个无头结点的单链表表示，栈名指针指向栈顶元素，相当于顺序栈栈顶指针，但有不同，顺序栈栈顶指针指向第一个空位置。


![](picture/3/2.png '')

```
栈的链式存储结构定义:

Status InitStack(LinkStack &S){
     S=NULL;
}

Status Push(LinkStack &S，SElemType e){
//将元素e插入到栈S的顶部
  SNode *p=(SNode *)malloc(sizeof(SNode));
  p->data=e; p->next=S；
  S=p;
}

Status Pop(LinkStack &S，SElemType &e){
  //删除栈顶元素并用e返回
  if(S==NULL)return ERROR;
  e=S->data;
  p=S;
  S=S->next;
  free(p);p=NULL;
}//遍历/销毁/清空/求表长均O(n)，其余O(1)


```

3.2 栈的应用





