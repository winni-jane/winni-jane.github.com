一、数据（内存分布图）
CPU+内存（数据段和堆栈段）；CPU负责执行指令，内存负责存放指令及指令的数据等等。。。

![](./picture/c/2.png '描述')

二、函数和栈空间：
 执行流程:

        当代码编译运行以后，会生成一个可执行的二进制文件【在硬盘上】，CPU会把这个可执行的二进制文件拷贝到内存里面去，然后在内存里面打开，按时间先后顺序，一条一条的执行。首先，会遇到main函数，此时，会压一个main栈(num1，num2都在main栈里面，是局部变量)，遇到printSum(num1, num2)函数，会压一个printSum栈(a,b都在这里面，也是一个局部变量)，遇到return 0 将a+b的值返回给printSum函数，然后prinSum出栈，将这个值赋值给ret，遇到printf又会压一个printf栈，输出里面的内容，完成后，释放掉（出）printf栈。往下执行，遇到return 0  程序正常结束，然后 main函数出栈。

三、全局变量:
    作用域:  整个工程的所有文件里面 都可以用.

    内存布局:  数据段    不会伴随栈的消失而消失 数据段和栈段是两个独立的内存区域.
               数据段有自己的生命周期：整个程序结束 数据才会释放.
               什么时候申请空间？ 编译的时候申请空间.

    生命周期:  直到程序结束.


四、静态局部变量

作用域：在这个变量声明的{}内。

 内存布局：数据段（）。

 生命周期：程序结束。
 
 详细特点如以下：

 1.该变量在全局数据区分配内存；
 2.静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；
 3.静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
 4.它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；

五、数组

求数组元素的个数：sizeof(a)/sizeof(a[0]);

字符数组：char a[20];

int a[5] = {1,3,5,7,9};

赋值：for (int i = 0; i < 5; i++) {
           a[i] = b[i];
    }











